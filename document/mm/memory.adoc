= memory.c 程序
== 功能描述

本程序进行内存分页的管理。实现了对主内存区内存的动态分配和收回操作。对于物理内存的管理， 内核使用了一个字节数组(mem_map[])来表示主内存区中所有物理内存页的状态。每个字节描述一个 物理内存页的占用状态。其中的值表示被占用的次数，0 表示对应的物理内存空闲着。当申请一页物理 内存时，就将对应字节的值增 1。对于进程虚拟线性地址的管理，内核使用了处理器的页目录表和页表 结构来管理。而物理内存页与进程线性地址之间的映射关系则是通过修改页目录和页表项的内容来处理。 下面对程序中所提供的几个主要函数进行详细说明。

get_free_page()和 free_page()这两个函数是专门用来管理主内存区中物理内存的占用和空闲情况，与 每个进程的线性地址无关。

get_free_page()函数用于在主内存区中申请一页空闲内存页，并返回物理内存页的起始地址。它首先 扫描内存页面字节图数组 mem_map[]，寻找值是 0 的字节项(对应空闲页面)。若无则返回 0 结束，表 示物理内存已使用完。若找到值为 0 的字节，则将其置 1，并换算出对应空闲页面的起始地址。然后对 该内存页面作清零操作。最后返回该空闲页面的物理内存起始地址。

free_page()用于释放指定地址处的一页物理内存。它首先判断指定的内存地址是否<1M，若是则返 回，因为 1M 以内是内核专用的;若指定的物理内存地址大于或等于实际内存最高端地址，则显示出错 信息;然后由指定的内存地址换算出页面号: (addr - 1M)/4K;接着判断页面号对应的 mem_map[]字节项 是否为 0，若不为 0，则减 1 返回;否则对该字节项清零，并显示“试图释放一空闲页面”的出错信息。

free_page_tables()和 copy_page_tables()这两个函数则以一个页表对应的物理内存块(4M)为单位， 释放或复制指定线性地址和长度(页表个数)对应的物理内存页块。不仅对管理线性地址的页目录和页 表中的对应项内容进行修改，而且也对每个页表中所有页表项对应的物理内存页进行释放或占用操作。

free_page_tables()用于释放指定线性地址和长度(页表个数)对应的物理内存页。它首先判断指定的 线性地址是否在 4M 的边界上，若不是则显示出错信息，并死机;然后判断指定的地址值是否=0，若是， 则显示出错信息“试图释放内核和缓冲区所占用的空间”，并死机;接着计算在页目录表中所占用的目录 项数 size，也即页表个数，并计算对应的起始目录项号;然后从对应起始目录项开始，释放所占用的所 有 size 个目录项;同时释放对应目录项所指的页表中的所有页表项和相应的物理内存页;最后刷新页变 换高速缓冲。

copy_page_tables()用于复制指定线性地址和长度(页表个数)内存对应的页目录项和页表，从而被 复制的页目录和页表对应的原物理内存区被共享使用。该函数首先验证指定的源线性地址和目的线性地 址是否都在 4Mb 的内存边界地址上，否则就显示出错信息，并死机;然后由指定线性地址换算出对应的 起始页目录项(from_dir, to_dir);并计算需复制的内存区占用的页表数(即页目录项数);接着开始分别 将原目录项和页表项复制到新的空闲目录项和页表项中。页目录表只有一个，而新进程的页表需要申请 空闲内存页面来存放;此后再将原始和新的页目录和页表项都设置成只读的页面。当有写操作时就利用 页异常中断调用，执行写时复制操作。最后对共享物理内存页对应的字节图数组 mem_map[]的标志进行 增1操作。

put_page()用于将一指定的物理内存页面映射到指定的线性地址处。它首先判断指定的内存页面地址 的有效性，要在 1M 和系统最高端内存地址之外，否则发出警告;然后计算该指定线性地址在页目录表 中对应的目录项;此时若该目录项有效(P=1)，则取其对应页表的地址;否则申请空闲页给页表使用， 并设置该页表中对应页表项的属性。最后仍返回指定的物理内存页面地址。

do_wp_page()是页异常中断过程(在 mm/page.s 中实现)中调用的页写保护处理函数。它首先判断 地址是否在进程的代码区域，若是则终止程序(代码不能被改动);然后执行写时复制页面的操作(Copy on Write)。

do_no_page()是页异常中断过程中调用的缺页处理函数。它首先判断指定的线性地址在一个进程空 间中相对于进程基址的偏移长度值。如果它大于代码加数据长度，或者进程刚开始创建，则立刻申请一 页物理内存，并映射到进程线性地址中，然后返回;接着尝试进行页面共享操作，若成功，则立刻返回; 否则申请一页内存并从设备中读入一页信息;若加入该页信息时，指定线性地址+1 页长度超过了进程代 码加数据的长度，则将超过的部分清零。然后将该页映射到指定的线性地址处。

get_empty_page()用于取得一页空闲物理内存并映射到指定线性地址处。主要使用了 get_free_page() 和 put_page()函数来实现该功能。

== 其他信息

=== 页异常的处理

当处理器在转换线性地址到物理地址的过程中检测到以下两种条件时，就会发生页异常中断14。

* 当 CPU 发现对应页目录项或页表项的存在位(Present)标志为 0。

* 当前进程没有访问指定页面的权限。

对于页异常处理中断，CPU 提供了两项信息用来诊断页异常和从中恢复运行。

* (1) 放在堆栈上的出错码。该出错码指出了异常是由于页不存在引起的还是违反了访问权限引起的;
在发生异常时 CPU 的当前特权层;以及是读操作还是写操作。出错码的格式是一个 32 位的长 字。但只用了最后的 3 个比特位。分别说明导致异常发生时的原因:
位 2(U/S) - 0 表示在超级用户模式下执行，1 表示在用户模式下执行; 位 1(W/R) - 0 表示读操作，1 表示写操作;
位 0(P) - 0 表示页不存在，1 表示页级保护。

* (2) CR2(控制寄存器2)。CPU将造成异常的用于访问的线性地址存放在CR2中。异常处理程序可以 使用这个地址来定位相应的页目录和页表项。如果在页异常处理程序执行期间允许发生另一个 页异常，那么处理程序应该将 CR2 压入堆栈中。